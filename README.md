# 한국산업기술대학교 게임공학부
#### 2017년도 인공지능 과목 - 과제물 정리  

## 내용
* **사용 언어** - C++  
* **Mat Buckland Programming Game AI by Example Source**를 기반으로 게임 객체(Agent)의 인공지능 구현에 대해 학습.  

### 과제 1
* 정의된 몇가지의 **행동 패턴**에 따라 움직이는 객체를 생성.
* 객체가 해야할 행동들이 관리되지 않아 다른 객체와 상호작용을 하거나 행동이 많아질 수록 구현이 복잡해짐.  

### 과제 4
* 과제 1에 이어, **FSM**(**Finite State Machine**)으로 다수의 Agent와 각각의 상태들을 관리하도록 함.  
-> **상태기계**(**State Machine**)와 **상태**(**States**)들을 구현.  
-> 모든 상태들은 **Singleton**으로 구현하여 같은 종류의 객체들이 메소드를 공유하여 사용하도록 함. (메모리 절약)
* 한번에 하나의 상태를 유지하되, 객체마다 **전역상태**를 두어 확률적으로 특별한 이벤트를 걸 수 있도록 함.  

### 과제 6
* 과제 4에 이어, 각 Agent들이 서로 **상호작용**을 하도록 구현.
* 객체들이 **메시지**(Message)를 송수신하면서, 받은 메시지에 따라 해야할 행동을 정하도록 함.  
-> 메시지는 메시지 관리 객체에 의해 관리되며, 지연시간(Delay)를 줄 수도 있음.  
-> (ex) '아내' 객체가 **요리를 시작**할 때, **자신**에게 일정 시간 후 **요리 완료** 메시지를 받을 수 있게 끔 메시지를 전송.  
그리고 '이전 상태'의 행동을 마저 하거나 '요리 하는 중'의 상태에 있다가, **요리 완료** 메시지를 받는 순간 다른 객체들에게 상호작용 메시지를 전송.  

### 과제 7
* 구현된 **길찾기 알고리즘**(PathFinder) 예제 소스를 분석하고 DFS, BFS, Dijkstra, A* 를 이용한 그래프 탐색 (길찾기 알고리즘) 학습.
* 또한, **반복적 깊이증가 탐색** (Iterative Deepening DFS) 방법을 추가 구현.  
-> 기존의 DFS를 기반으로 구현. (DFS는 스택으로 구현되었음.)  
-> **제한 깊이** 변수와 **노드의 깊이 값들**을 저장하는 버퍼를 두고, 반복적으로 초기화하면서 DFS를 수행.  
-> 트리가 확장될 때 (탐색 깊이가 증가할 때) 깊이가 **제한 깊이 보다 작을 경우**에만 스택에 삽입하도록 함.  
-> 목표 노드 까지의 경로를 찾지 못했을 경우 **제한 깊이를 1 증가** 시키고 반복 수행.  
-> 해답이 존재하지 않을 수 있으므로, 제한 깊이에도 제한을 두고 수행함. (limit = abs(시작 - 목표))  

### 과제 10
* **N-Queen 문제**를 A* 알고리즘으로 해결하도록 구현.  
-> N-Queen 문제의 각 **Case**들은 항상 **Unique** 하기 때문에 **중복 검사**와 **비용 수정**은 제외함.  
-> 단, 모든 경우를 살펴봐야 하는 단점이 있기 때문에 가지치기를 이용함.  
  (Queen이 하나라도 겹치는 경우 무효화)  
-> 성능 비교를 위해 Backtracking DFS 알고리즘으로도 구현.  

* **Heuristic**  
**~~1. 경로가 겹쳐진 퀸의 개수~~**  
-> 가지치기에서 걸러지기 때문에 소용이 없음. (실패)  
**~~2. 보드 위에 퀸을 배치할 수 있는 유효한 칸의 개수~~**  
-> 유용하긴 하나, 이를 구하는 비용이 너무 무거움. (실패)  
**3. 휴리스틱을 사용하지 않고 Dijkstra로 구현**  
-> 현재 상태. (가장 빠름)  

* A* 알고리즘으로 구현 했을 경우, 하나의 해답을 찾는 속도는 매우 빠름.  
-> 하지만 모든 해를 구하는 속도는 Backtracking DFS에 비해 느림.  

### 과제 11  
* 구현된 **Steering Behavior** 예제 소스를 분석해 자연스럽게 움직이는 AI 구현 방법을 학습.  
-> 여러가지 상태를 동시에 가질 수 있으며(bitflag 활용), 각 상태에 따른 **가중치**를 부여하여 적절한 **힘을 가해 이동**함.  
-> '새 무리'(Birds)들이 집단 행동을 하는 것 처럼 다수의 Agent들이 이웃 Agent들과 비슷한 형태로 이동하거나,  
특정 Agent를 회피 or 추격하는 방법 등 다양한 AI를 학습.  

* 여기서, (1) **특정 Agent** 가 (2) **나머지 Agent** 들을 마주치면, 마주친 (2)들이 (1)의 뒤에 1열로 따라오도록 구현함.  
-> (어미 거위와 새끼 거위들)  
-> **회피**의 방법을 반대로 이용하여 '**어미와 새끼의 마주침**'을 구현.  
-> **추격**을 이용해 새끼들이 1열로 따라오도록 구현.  
  (마지막 객체를 class static 변수로 지정하여 해당 객체를 따라 가도록 하고, 마지막 객체가 자신이 되도록 갱신하는 방식으로 구현.)  
-> 붙잡힌 객체와 아닌 객체를 구분하기 위해 색을 다르게 지정함.
